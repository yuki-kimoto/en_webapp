<h2>ログイン機能を使ったユーザー認証の作り方</h2>

ログイン機能を使ったユーザー認証の作り方について書きます。Webアプリケーションのユーザー認証って難しそうだなと感じていませんか。どうやってログイン機能を作ったらよいかわからないそういう疑問を解決できる記事を書きます。

記事を書いた後に、Webサービスのスタートアップに必要な、MojoliciousとMySQLにおけるログイン機能を使った、ユーザー認証のサンプルコードを書いてみますね。

<h3>ログイン機能を使ったユーザー認証とは何か</h3>

ログイン機能を使ったユーザー認証とは何かについて解説していきます。

<h4>ユーザー認証とは何か</h4>

ユーザー認証とは、ユーザーを識別する機能のことを言います。木本さんが操作している、田中さんが操作しているなど、どのユーザーが今操作しているかを識別するための機能です。

<h4>ログイン機能とは何か</h4>

一般的に、Webアプリケーションでは、ユーザーIDとパスワード、あるいは、メールアドレスとパスワードを指定して、ログイン機能を使って、ユーザー認証を実装します。この記事では、この機能のことをログイン機能と呼びます。

ユーザー認証には、ベーシック認証や、OAuthなどの別の認証方式もあるので、アプリケーションで実装するユーザー認証機能をログイン機能という名前で呼ぶことにします。

広くよく見られるログイン画面からログインする機能のことです。

<h4>ユーザーID</h4>

ユーザーIDは「kimoto_yuki01」のように英数字の場合もあれば「0012345」のように数字だけのものもあります。どちらの場合も同じロジックで処理できます。

英数字の場合はASCIIコードの「a-zA-Z0-9_」だけに限定しておくようにすればよいかと思います。

ユーザーIDは、ユーザーが決めることができるようにすることもできますし、サービス提供側が決めることができるようにすることもできます。

ユーザーIDまたは、メールアドレスは、一意であることが必要です。ユニーク制約を設定します。

ユーザーIDを使ってユーザー認証を行う場合は、ユーザーのメールアドレスの変更を行うことができるのは、当然ですが、メールアドレスを使ってユーザー認証を作った場合でも、メールアドレスの変更は可能ですので、安心してください。ユーザーテーブルを作るときに、行を一意に識別できるIDの列を作成して、プライマリーキー制約とオートインクリメントを設定します。

<h4>パスワードの安全性</h4>

パスワードは、ASCIIコードの見ることが可能な文字で表現します。「a-zA-Z0-9」とASCIIの記号「&@」など。キーボードで打てる文字で、文字の制限を行うと考えてください。

セキュリティを高めるために、文字数は、8文字以上と制約を書けると安全です。パスワードは長ければ長いほど安全ですが、利便性もあるので、安全性について、パスワードを決める画面で、ユーザーが知ることができると、親切です。

英語と数字と記号のすべてが入っているというのも、少しだけ安全性を上げるでしょう。

パスワードは、ユーザーテーブルに、そのまま保存しては、絶対にいけません。ユーザーデータが流出すると、そのパスワードをそのまま入力することで、他のサービスにログインできる危険性があるからです。そんなことは、当然だと、思うかもしれませんが、僕はパスワードが生で保存されているテーブルを実際に目にしてきました。

パスワードは、ハッシュ関数を使って、その値を保存します。ハッシュ関数を使うと、元のパスワードが、どんな文字列であったのかを、知ることができません。もう少し、正確に言うと、知ることがほぼ不可能になります。ソルトと呼ばれる値を、付け加えておくと、より安全性が高まります。これについては、後で、詳しく解説します。

<h4>HTTP通信とユーザー認証</h4>

Webの標準的なプロトコルであるHTTP通信は、ステートレスであることが前提です。ステートレスとは、状態を持たないことで、HTTPリクエストがあって、HTTPレスポンスを返すというのがひとつの処理で、それぞれのHTTPリクエストが独立しています。

HTTP自体は、接続を持続するという機能を持っていません。(HTTP 2.0のことはこの記事では触れません)。

ベーシック認証や、ダイジェスト認証が定義されていますが、これは、HTTP通信上の認証なので、アプリケーションに統合することができません。

結局のところ、ユーザーにサービスを提供するためのユーザー認証は、アプリケーション側で、行う必要があるということです。

HTTPは、クッキーと呼ばれる、クライアント側にデータを保存する機能を持っています。このクッキーの機能をうまく使って、ユーザー認証を実装することになります。

ログインのタイミングで、セッションIDと呼ばれるものを、アプリケーション側で発行して、それを、クッキーに保存してもらいます。そして、クッキーに保存されたセッションIDを、送信してもらい、アプリケーション側で、ユーザーを識別します。

<h3>パスワードをどのように保存するか</h3>

ログイン機能を使ったユーザー認証を作る場合は、ユーザーがパスワードを入力します。このパスワードを盗まれても安全なように保存しておく必要があります。

パスワードそのままを保存した場合は、サーバーで作業している人は、データベースでSQLを実行して、ユーザーIDとパスワードをそのまま見ることができます。これは、セキュリティ上よろしくありません。

ですので、パスワードをそのまま保存するのではなく、パスワードにハッシュ関数を実行した値を保存しておくことになります。

<h4>ハッシュ関数とは</h4>

ハッシュ関数とは、ある値を与えたときに、ひとつの値を出力する関数です。

<pre>
# ハッシュ関数
my $hash_value = hash_func($value);
</pre>

「えっ、これがハッシュ関数」なのと言われると、これがハッシュ関数なのだというしかありません。すごく難しいと信じ込んでいた方は、びっくりされるでしょう。

ただし、良いハッシュ関数と悪いハッシュ関数があり、良いハッシュ関数を選ぶ必要があるのです。

良いといわれるハッシュ関数の条件は以下です。

<ul>
  <li>ハッシュ値から元の値を推測されないこと</li>
  <li>異なる入力に対して、出力されるハッシュ値がなるべく重複しないこと</li>
</ul>

元の値を推測されるということは、パスワードが知られてしまうということです。パスワードが簡単に知られてしまうようでは、困りますね。ですので、良いハッシュ関数は、元の値を推測されにくいということが必要です。

パスワードの場合は、ハッシュ値が重複しないことは、あまり必要な要件ではありませんが、ハッシュ値を、ユニークIDとして扱いたい場合は、異なる入力に対して、出力されるハッシュ値がなるべく重複しないということが重要です。これは、後ほど、セッションIDを作成する上で、必要になりますので、頭に入れておいてください。

ちなみに、ハッシュ関数は、Perlのハッシュとは何の関係もありません。

<h4>bcryptでパスワードをハッシュ化する</h4>

2019年の調査の結果、パスワードをハッシュ化するには、bcryptが良いようです。PHP 7では、bcryptのアルゴリズムが、デフォルトで採用されています。

bcryptは、入力値が短くても(パスワードは短い)、元の値を推測するのに、ある程度の計算時間がかかるハッシュ関数のアルゴリズムのようです。

Perlにおけるbcryptの実装は<a href="https://metacpan.org/source/Crypt::Eksblowfish::Bcrypt">Crypt::Eksblowfish::Bcrypt</a>で利用できます。

Mojoliciousでは、プラグインとして<a href="https://metacpan.org/release/Mojolicious-Plugin-Bcrypt/source/lib/Mojolicious/Plugin/Bcrypt.pm">Mojolicious::Plugin::Bcrypt</a>があります。

<pre>
# 登録時にハッシュ化されたパスワードを作る
sub signup {
    my $self = shift;
    my $crypted_pass = $self->bcrypt( $self->param('password') );
    ...
}

# ログイン時にパスワードをチェック
sub login {
    my $self = shift;
    my $entered_pass = $self->param('password');
    my $crypted_pass = $self->get_password_from_db();
    if ( $self->bcrypt_validate( $entered_pass, $crypted_pass ) ) {
 
        # Authenticated
        ...;
    }
    else {
 
        # Wrong password
        ...;
    }
}
</pre>

bcryptで生成されたハッシュ化されたパスワードを、ユーザーテーブルのパスワードに保存しましょう。

将来的にさらに強度の高いアルゴリズムがでてきた場合のために、bcryptを自作のpassword_hash関数で、bcrypt_validateを自作のpassword_validate関数で、ラッピングしておくと、保守性が高くなるかもしれませんね。

(記事執筆途中。追加、修正あり)

