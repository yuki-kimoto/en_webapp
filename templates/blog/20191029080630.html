<h2>ログイン機能を使ったユーザー認証の作り方</h2>

ログイン機能を使ったユーザー認証の作り方について書きます。Webアプリケーションのユーザー認証って難しそうだなと感じていませんか。どうやってログイン機能を作ったらよいかわからないそういう疑問を解決できる記事を書きます。

記事を書いた後に、Webサービスのスタートアップに必要な、MojoliciousとMySQLにおけるログイン機能を使った、ユーザー認証のサンプルコードを書いてみますね。

<h3>ログイン機能を使ったユーザー認証とは何か</h3>

ログイン機能を使ったユーザー認証とは何かについて解説していきます。

<h4>ユーザー認証とは何か</h4>

ユーザー認証とは、ユーザーを識別する機能のことを言います。木本さんが操作している、田中さんが操作しているなど、どのユーザーが今操作しているかを識別するための機能です。

<h4>ログイン機能とは何か</h4>

一般的に、Webアプリケーションでは、ユーザーIDとパスワード、あるいは、メールアドレスとパスワードを指定して、ログイン機能を使って、ユーザー認証を実装します。この記事では、この機能のことをログイン機能と呼びます。

ユーザー認証には、ベーシック認証や、OAuthなどの別の認証方式もあるので、アプリケーションで実装するユーザー認証機能をログイン機能という名前で呼ぶことにします。

広くよく見られるログイン画面からログインする機能のことです。

<h4>ユーザーID</h4>

ユーザーIDは「kimoto_yuki01」のように英数字の場合もあれば「0012345」のように数字だけのものもあります。どちらの場合も同じロジックで処理できます。

英数字の場合はASCIIコードの「a-zA-Z0-9_」だけに限定しておくようにすればよいかと思います。

ユーザーIDは、ユーザーが決めることができるようにすることもできますし、サービス提供側が決めることができるようにすることもできます。

ユーザーIDまたは、メールアドレスは、一意であることが必要です。ユニーク制約を設定します。

ユーザーIDを使ってユーザー認証を行う場合は、ユーザーのメールアドレスの変更を行うことができるのは、当然ですが、メールアドレスを使ってユーザー認証を作った場合でも、メールアドレスの変更は可能ですので、安心してください。ユーザーテーブルを作るときに、行を一意に識別できるIDの列を作成して、プライマリーキー制約とオートインクリメントを設定します。

<h4>パスワードの安全性</h4>

パスワードは、ASCIIコードの見ることが可能な文字で表現します。「a-zA-Z0-9」とASCIIの記号「&@」など。キーボードで打てる文字で、文字の制限を行うと考えてください。

セキュリティを高めるために、文字数は、8文字以上と制約を書けると安全です。パスワードは長ければ長いほど安全ですが、利便性もあるので、安全性について、パスワードを決める画面で、ユーザーが知ることができると、親切です。

英語と数字と記号のすべてが入っているというのも、少しだけ安全性を上げるでしょう。

パスワードは、ユーザーテーブルに、そのまま保存しては、絶対にいけません。ユーザーデータが流出すると、そのパスワードをそのまま入力することで、他のサービスにログインできる危険性があるからです。そんなことは、当然だと、思うかもしれませんが、僕はパスワードが生で保存されているテーブルを実際に目にしてきました。

パスワードは、ハッシュ関数を使って、その値を保存します。ハッシュ関数を使うと、元のパスワードが、どんな文字列であったのかを、知ることができません。もう少し、正確に言うと、知ることがほぼ不可能になります。ソルトと呼ばれる値を、付け加えておくと、より安全性が高まります。これについては、後で、詳しく解説します。

<h4>HTTP通信とユーザー認証</h4>

Webの標準的なプロトコルであるHTTP通信は、ステートレスであることが前提です。ステートレスとは、状態を持たないことで、HTTPリクエストがあって、HTTPレスポンスを返すというのがひとつの処理で、それぞれのHTTPリクエストが独立しています。

HTTP自体は、接続を持続するという機能を持っていません。(HTTP 2.0のことはこの記事では触れません)。

ベーシック認証や、ダイジェスト認証が定義されていますが、これは、HTTP通信上の認証なので、アプリケーションに統合することができません。

結局のところ、ユーザーにサービスを提供するためのユーザー認証は、アプリケーション側で、行う必要があるということです。

HTTPは、クッキーと呼ばれる、クライアント側にデータを保存する機能を持っています。このクッキーの機能をうまく使って、ユーザー認証を実装することになります。

ログインのタイミングで、セッションIDと呼ばれるものを、アプリケーション側で発行して、それを、クッキーに保存してもらいます。そして、クッキーに保存されたセッションIDを、送信してもらい、アプリケーション側で、ユーザーを識別します。

<h3>パスワードをどのように保存するか</h3>

ログイン機能を使ったユーザー認証を作る場合は、ユーザーがパスワードを入力します。このパスワードを盗まれても安全なように保存しておく必要があります。

パスワードそのままを保存した場合は、サーバーで作業している人は、データベースでSQLを実行して、ユーザーIDとパスワードをそのまま見ることができます。これは、セキュリティ上よろしくありません。

ですので、パスワードをそのまま保存するのではなく、パスワードにハッシュ関数を実行した値を保存しておくことになります。

<h4>ハッシュ関数とは</h4>

ハッシュ関数とは、ある値を与えたときに、ひとつの値を出力する関数です。

<pre>
# ハッシュ関数
my $hash_value = hash_func($value);
</pre>

「えっ、これがハッシュ関数」なのと言われると、これがハッシュ関数なのだというしかありません。すごく難しいと信じ込んでいた方は、びっくりされるでしょう。

ただし、良いハッシュ関数と悪いハッシュ関数があり、良いハッシュ関数を選ぶ必要があるのです。

良いといわれるハッシュ関数の条件は以下です。

<ul>
  <li>ハッシュ値から元の値を推測されないこと</li>
  <li>異なる入力に対して、出力されるハッシュ値がなるべく重複しないこと</li>
</ul>

元の値を推測されるということは、パスワードが知られてしまうということです。パスワードが簡単に知られてしまうようでは、困りますね。ですので、良いハッシュ関数は、元の値を推測されにくいということが必要です。

パスワードの場合は、ハッシュ値が重複しないことは、あまり必要な要件ではありませんが、ハッシュ値を、ユニークIDとして扱いたい場合は、異なる入力に対して、出力されるハッシュ値がなるべく重複しないということが重要です。これは、後ほど、セッションIDを作成する上で、必要になりますので、頭に入れておいてください。

ちなみに、ハッシュ関数は、Perlのハッシュとは何の関係もありません。

<h4>bcryptでパスワードをハッシュ化する</h4>

2019年の調査の結果、パスワードをハッシュ化するには、bcryptが良いようです。PHP 7では、bcryptのアルゴリズムが、デフォルトで採用されています。

bcryptは、入力値が短くても(パスワードは短い)、元の値を推測するのに、ある程度の計算時間がかかるハッシュ関数のアルゴリズムのようです。

Perlにおけるbcryptの実装は<a href="https://metacpan.org/pod/release/ZEFRAM/Crypt-Eksblowfish-0.009/lib/Crypt/Eksblowfish.pm">Crypt::Eksblowfish::Bcrypt</a>で利用できます。

Mojoliciousでは、プラグインとして<a href="https://metacpan.org/pod/release/MINIMAL/Mojolicious-Plugin-Bcrypt-0.14/lib/Mojolicious/Plugin/Bcrypt.pm">Mojolicious::Plugin::Bcrypt</a>があります。

<pre>
# 登録時にハッシュ化されたパスワードを作る
sub signup {
    my $self = shift;
    my $crypted_pass = $self->bcrypt( $self->param('password') );
    ...
}

# ログイン時にパスワードをチェック
sub login {
    my $self = shift;
    my $entered_pass = $self->param('password');
    my $crypted_pass = $self->get_password_from_db();
    if ( $self->bcrypt_validate( $entered_pass, $crypted_pass ) ) {
 
        # Authenticated
        ...;
    }
    else {
 
        # Wrong password
        ...;
    }
}
</pre>

bcryptで生成されたハッシュ化されたパスワードを、ユーザーテーブルのパスワードに保存しましょう。

将来的にさらに強度の高いアルゴリズムがでてきた場合のために、bcryptを自作のpassword_hash関数で、bcrypt_validateを自作のpassword_validate関数で、ラッピングしておくと、保守性が高くなるかもしれませんね。

Mojolicious以外の場合は、Mojolicious::Plugin::Bcryptのソースコードは、Mojoliciousに依存していなくて、とても簡単なので、コピペして利用できそうです。

<h3>セッションIDを生成する方法</h3>

ユーザー認証において、少し難しいのは、初回のログイン以外は、セッションIDを使って、ユーザーを識別するということです。

ログイン画面から、ログインをするときは、ユーザーIDとパスワードを使ってユーザーを認証するのですが、認証後は、セッションIDを使ってユーザーを識別します。

<h4>セッションIDとは</h4>

セッションIDとは、ユーザーを識別するための文字の並びのことです。セッションIDのサンプルを書いてみます。

<pre>
# セッションIDのサンプル
aabc73ce3
deab33cea
a567c73c1
</pre>

本物のセッションIDはもっと長い方がよいのですが、ここでは雰囲気だけ。16進数の文字を並べていますが、「a-z」「A-Z」「0-9」などのランダムな文字の並びで構いません。

<h4>セッションIDは一意性が高く、十分に長くなければならない</h4>

セッションIDは、単なる文字列の並びですが、ユーザー識別に利用するために、いくつかの要件を満たしている必要があります。

ユーザー識別には、まずそのユーザーを識別できるということが求められます。

たとえば、ユーザーが1万人いるとしたら、セッションIDが5000人分しかないと、困りますね。

また、セッションIDを発行したときに、他のユーザーと重なってしまったというのも困りますね。

またセッションIDが短ければ、推測される可能性も高まります。セキュリティ的にも、文字の種類が多く、長い方がよいのです。

セッションIDは単なるランダムな文字列の並びで良いのですが、一意性を確保したい場合に、衝突が起こるのが極めて小さいハッシュ関数を使うのが簡単です。

ハッシュ関数で生成する場合は、文字種は「0-9a-z」の16文字ですので、なるべく文字の長さが長くなるようにするのが安全です。

SHA-1で40文字、SHA-256で64文字、SHA-512で128文字です。

<pre>
SHA-1
356a192b7913b04c54574d18c28d46e6395428ab

SHA-256
6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b

SHA-512
4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a
</pre>

セッションIDは、ユーザーが覚える必要がないので長くしても大丈夫です。

<h4>セッションIDは、ユーザーを識別し、永続的ではなく、推測されにくい必要がある</h4>

セッションIDを作成する場合に、ハッシュ関数を使うのですが、入力を何にするかということは、考える必要があります。

もし、ユーザー名にすれば、簡単に推測されてしまいそうです。この場合、ユーザー名とハッシュ関数の種類がわかれば、出力がわかるわけですね。

また、セッションIDが永続的に変わらないということにもなってしまします。セッションIDは、期限が来ると無効になる必要があるわけです。

時刻の情報を、ユーザー名の末尾に、付け足しましょう。こうすると永続性はなくなります。ユーザー名に対して一意ということもありません。

これで、十分でしょうか? まぁ、心配はなさそう? でも、もう少しセッションIDを強くしましょう。

ユーザー名と時刻というのは、ランダムな情報ではないですよね。攻撃者は、ユーザー名と時刻とハッシュ関数がわかれば、突破できます。

そこで、ランダムな数字というのを、末尾に付け足してあげます。100万くらいにしておきましょうか。

100万以下のランダムな数字を付け加える。

ですので、上記を踏まえて、セッションIDを生成してみましょう。ユーザー名と時刻とランダムな数をSHA-512のアルゴリズムのハッシュ関数に与えています。

<pre>
use strict;
use warnings;

use Digest::SHA 'sha512_hex';

# セッションIDを作成
my $user_id = 'kimoto';
my $time = time;
my $rand = int rand 1_000_000;
my $session_id = sha512_hex($user_id . $time . $rand);
print "$session_id\n";
</pre>

出力されたセッションIDの例

<pre>
e182aa93605c82a472c4986f2749b111f35042f2bb01a3ba9eba3603653cf5ca4d9eb540f1ae32eb4c8d280f18ccb4d5f58f614652c067c7c3175e9b58d29d1a
</pre>

ちなみにMojoliciousのセッション機能は、セッションIDを生成する方法とは何の関係もないので注意してください。Mojoliciousのセッションは、セッションIDを保存するのに利用できます。

<pre>
$c->session(session_id => $session_id);
</pre>

<h2>検討事項</h2>

セキュリティの専門家の方に聞きたいこと。

パスワード認証は、bcryptでよいか?

セッションIDがSHA-512の場合に、128文字になるが、不具合がでてくる事象はないか?

(記事執筆途中。追加、修正あり。最終更新2019年10月31日)

